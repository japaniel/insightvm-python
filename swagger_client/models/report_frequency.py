# coding: utf-8

"""
    InsightVM API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 3
    Contact: support@rapid7.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

import pprint
import re  # noqa: F401

import six

class ReportFrequency(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """
    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'next_runtimes': 'list[str]',
        'repeat': 'RepeatSchedule',
        'start': 'str'
    }

    attribute_map = {
        'next_runtimes': 'nextRuntimes',
        'repeat': 'repeat',
        'start': 'start'
    }

    def __init__(self, next_runtimes=None, repeat=None, start=None):  # noqa: E501
        """ReportFrequency - a model defined in Swagger"""  # noqa: E501
        self._next_runtimes = None
        self._repeat = None
        self._start = None
        self.discriminator = None
        if next_runtimes is not None:
            self.next_runtimes = next_runtimes
        self.repeat = repeat
        self.start = start

    @property
    def next_runtimes(self):
        """Gets the next_runtimes of this ReportFrequency.  # noqa: E501

        List the next 10 dates in the future the schedule will launch.   # noqa: E501

        :return: The next_runtimes of this ReportFrequency.  # noqa: E501
        :rtype: list[str]
        """
        return self._next_runtimes

    @next_runtimes.setter
    def next_runtimes(self, next_runtimes):
        """Sets the next_runtimes of this ReportFrequency.

        List the next 10 dates in the future the schedule will launch.   # noqa: E501

        :param next_runtimes: The next_runtimes of this ReportFrequency.  # noqa: E501
        :type: list[str]
        """

        self._next_runtimes = next_runtimes

    @property
    def repeat(self):
        """Gets the repeat of this ReportFrequency.  # noqa: E501


        :return: The repeat of this ReportFrequency.  # noqa: E501
        :rtype: RepeatSchedule
        """
        return self._repeat

    @repeat.setter
    def repeat(self, repeat):
        """Sets the repeat of this ReportFrequency.


        :param repeat: The repeat of this ReportFrequency.  # noqa: E501
        :type: RepeatSchedule
        """
        if repeat is None:
            raise ValueError("Invalid value for `repeat`, must not be `None`")  # noqa: E501

        self._repeat = repeat

    @property
    def start(self):
        """Gets the start of this ReportFrequency.  # noqa: E501

        The scheduled start date and time. Date is represented in ISO 8601 format. Repeating schedules will determine the next schedule to begin based on this date and time.  # noqa: E501

        :return: The start of this ReportFrequency.  # noqa: E501
        :rtype: str
        """
        return self._start

    @start.setter
    def start(self, start):
        """Sets the start of this ReportFrequency.

        The scheduled start date and time. Date is represented in ISO 8601 format. Repeating schedules will determine the next schedule to begin based on this date and time.  # noqa: E501

        :param start: The start of this ReportFrequency.  # noqa: E501
        :type: str
        """
        if start is None:
            raise ValueError("Invalid value for `start`, must not be `None`")  # noqa: E501

        self._start = start

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(ReportFrequency, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ReportFrequency):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
